from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from qiskit.quantum_info import Statevector
import matplotlib.pyplot as plt
import numpy as np

# --- 1. Define the state to be teleported (arbitrary single qubit state) ---
# Let's create a superposition state, e.g., |psi> = 1/sqrt(2) * (|0> + i|1>)
# This can be generated by applying H and S gates to |0>
state_to_teleport_qc = QuantumCircuit(1, name='initial_state')
state_to_teleport_qc.h(0)
state_to_teleport_qc.s(0) # S gate applies a phase to |1>

# Get the statevector for verification later
initial_statevector = Statevector(state_to_teleport_qc)
print("Initial State to be Teleported (Statevector):", initial_statevector)

# --- 2. Build the Teleportation Circuit ---
# Create a Quantum Circuit with 3 qubits (q0: sender's state, q1: sender's entangled, q2: receiver's entangled)
# and 3 classical bits for measurement results (c0, c1, c2)
qc = QuantumCircuit(3, 3)

# Add the initial state to the main circuit on q0
qc.append(state_to_teleport_qc, [0])
qc.barrier()

# Create Bell pair between q1 and q2 (sender's entangled and receiver's entangled)
qc.h(1)
qc.cx(1, 2)
qc.barrier()

# Sender performs Bell measurement on q0 and q1
qc.cx(0, 1)
qc.h(0)
qc.barrier()

# Measure q0 and q1, store results in c0 and c1
qc.measure([0, 1], [0, 1])
qc.barrier()

# Receiver applies corrections based on sender's measurement results
# These are classical operations, so we use `if_test` (or conditional gates)
with qc.if_test((1, 1)):
    qc.x(2)
with qc.if_test((0, 1)):
    qc.z(2)

# Measure the teleported qubit (q2) to see if it matches the original state (q0)
qc.measure(2, 2)

# Draw the circuit
print("\nQuantum Teleportation Circuit:")
print(qc.draw(output='text'))

# --- 3. Simulate the Circuit ---
simulator = AerSimulator()
compiled_circuit = transpile(qc, simulator)
job = simulator.run(compiled_circuit, shots=1024)
result = job.result()
counts = result.get_counts(compiled_circuit)

print(f"\nMeasurement Counts: {counts}")

# --- 4. Verify Teleportation (conceptual check by measurement) ---
# For a perfect verification, we would need to simulate each branch or use a classical post-processing.
# However, for demonstration, if all goes well, qubit 2 should contain the original state.

# Let's use the actual circuit execution result to verify. If the teleportation is perfect, 
# the measurement of q2 (the last bit in the classical output) should reflect the measurement 
# of the initial state. Since our initial state is 1/sqrt(2) * (|0> + i|1>), measuring it directly 
# would give 50/50 for 0 and 1. So, we expect the last bit in the results to be roughly 50/50.

# Expected outcome for q2, which should be similar to measuring the initial state
# Since initial state is 1/sqrt(2) * (|0> + i|1>), measurements of q0 or q2 should be ~50/50 for 0 and 1.

print("\nVerifying Teleportation (conceptual check): If teleportation was successful, the measurements of the third qubit (q2) should reflect the distribution of the initial state.")
print(f"Initial state measurement probability for |0>: {abs(initial_statevector[0]**2):.2f}")
print(f"Initial state measurement probability for |1>: {abs(initial_statevector[1]**2):.2f}")

# Analyze the counts for the last classical bit (which corresponds to q2)
teleported_counts = {}
for outcome, count in counts.items():
    teleported_bit = outcome[0] # The last bit in the output corresponds to the measurement of q2 (c2)
    teleported_counts[teleported_bit] = teleported_counts.get(teleported_bit, 0) + count

print(f"\nCounts for Teleported Qubit (q2): {teleported_counts}")

fig_hist = plot_histogram(teleported_counts, title="Measurement of Teleported Qubit (q2)")
plt.show()

# Plot the Bloch sphere for the initial state for visual reference
fig_bloch_initial = plot_bloch_multivector(initial_statevector, title="Initial State on Qubit 0")
plt.show()

# Note: Verifying teleportation requires either statevector simulation of the final qubit
# or statistical analysis of many shots, ensuring the *distribution* of measurements
# on the receiver's qubit matches the expected distribution of the sent state.
