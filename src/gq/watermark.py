#!/usr/bin/env python3
"""
Binary Watermark System for Commercial Licensing

This module provides secure watermarking capabilities for embedding licensing
data into binary files generated by this repository. The watermark embeds
traceable data into reserved byte sections without affecting deterministic
properties.

Compliance: Strictly adheres to COMMERCIAL_LICENSE.md requirements for
authorized commercial data distribution.

⚠️ NOT FOR CRYPTOGRAPHIC USE: This is for licensing and traceability only.
"""

import hashlib
import hmac
import json
import struct
import time
from typing import Dict, Optional, Tuple
from datetime import datetime


class WatermarkError(Exception):
    """Base exception for watermark operations."""
    pass


class WatermarkData:
    """
    Container for watermark licensing data.
    
    Attributes:
        license_id: Unique license identifier (max 64 chars)
        user_info: User or organization information (max 128 chars)
        timestamp: Unix timestamp of watermark creation
        signature: HMAC signature for verification
    """
    
    # Magic bytes to identify watermarked binaries
    MAGIC = b'SEED'
    VERSION = 1
    
    # Field size limits (in bytes)
    LICENSE_ID_SIZE = 64
    USER_INFO_SIZE = 128
    TIMESTAMP_SIZE = 8
    SIGNATURE_SIZE = 32
    
    # Total watermark size
    HEADER_SIZE = len(MAGIC) + 1  # Magic + version byte
    WATERMARK_SIZE = (HEADER_SIZE + LICENSE_ID_SIZE + 
                     USER_INFO_SIZE + TIMESTAMP_SIZE + SIGNATURE_SIZE)
    
    def __init__(self, license_id: str, user_info: str, 
                 timestamp: Optional[float] = None):
        """
        Initialize watermark data.
        
        Args:
            license_id: Unique license identifier
            user_info: User or organization information
            timestamp: Unix timestamp (defaults to current time)
            
        Raises:
            WatermarkError: If field size limits are exceeded
        """
        if len(license_id) > self.LICENSE_ID_SIZE:
            raise WatermarkError(
                f"License ID exceeds {self.LICENSE_ID_SIZE} bytes"
            )
        if len(user_info) > self.USER_INFO_SIZE:
            raise WatermarkError(
                f"User info exceeds {self.USER_INFO_SIZE} bytes"
            )
        
        self.license_id = license_id
        self.user_info = user_info
        self.timestamp = timestamp if timestamp is not None else time.time()
        self.signature = b''
    
    def to_dict(self) -> Dict:
        """Convert watermark data to dictionary."""
        return {
            'license_id': self.license_id,
            'user_info': self.user_info,
            'timestamp': self.timestamp,
            'timestamp_readable': datetime.fromtimestamp(
                self.timestamp
            ).isoformat(),
        }
    
    def __repr__(self) -> str:
        return (f"WatermarkData(license_id='{self.license_id}', "
                f"user_info='{self.user_info}', "
                f"timestamp={self.timestamp})")


def _calculate_signature(data: bytes, secret: str) -> bytes:
    """
    Calculate HMAC signature for watermark data.
    
    Args:
        data: Data to sign
        secret: Secret key
        
    Returns:
        HMAC-SHA256 signature
    """
    key = secret.encode('utf-8')
    return hmac.new(key, data, hashlib.sha256).digest()


def encode_watermark(watermark: WatermarkData, secret: str) -> bytes:
    """
    Encode watermark data into binary format with cryptographic signature.
    
    The binary format:
        - 4 bytes: Magic bytes ('SEED')
        - 1 byte: Version
        - 64 bytes: License ID (null-padded)
        - 128 bytes: User info (null-padded)
        - 8 bytes: Timestamp (double, big-endian)
        - 32 bytes: HMAC-SHA256 signature
    
    Args:
        watermark: Watermark data to encode
        secret: Secret key for signature generation
        
    Returns:
        Binary watermark data
        
    Raises:
        WatermarkError: If encoding fails
    """
    try:
        # Create payload without signature
        payload = bytearray()
        
        # Magic and version
        payload.extend(WatermarkData.MAGIC)
        payload.append(WatermarkData.VERSION)
        
        # License ID (null-padded)
        license_bytes = watermark.license_id.encode('utf-8')
        payload.extend(license_bytes)
        payload.extend(b'\x00' * (WatermarkData.LICENSE_ID_SIZE - len(license_bytes)))
        
        # User info (null-padded)
        user_bytes = watermark.user_info.encode('utf-8')
        payload.extend(user_bytes)
        payload.extend(b'\x00' * (WatermarkData.USER_INFO_SIZE - len(user_bytes)))
        
        # Timestamp (double, big-endian)
        payload.extend(struct.pack('>d', watermark.timestamp))
        
        # Calculate and append signature
        signature = _calculate_signature(bytes(payload), secret)
        payload.extend(signature)
        
        return bytes(payload)
    
    except Exception as e:
        raise WatermarkError(f"Failed to encode watermark: {e}")


def decode_watermark(data: bytes, secret: str) -> WatermarkData:
    """
    Decode and verify watermark data from binary format.
    
    Args:
        data: Binary watermark data
        secret: Secret key for signature verification
        
    Returns:
        Decoded watermark data
        
    Raises:
        WatermarkError: If decoding or verification fails
    """
    if len(data) < WatermarkData.WATERMARK_SIZE:
        raise WatermarkError(
            f"Invalid watermark size: {len(data)} bytes "
            f"(expected {WatermarkData.WATERMARK_SIZE})"
        )
    
    # Check magic bytes
    magic = data[:4]
    if magic != WatermarkData.MAGIC:
        raise WatermarkError(f"Invalid magic bytes: {magic}")
    
    # Check version
    version = data[4]
    if version != WatermarkData.VERSION:
        raise WatermarkError(f"Unsupported version: {version}")
    
    offset = WatermarkData.HEADER_SIZE
    
    # Extract license ID
    license_end = offset + WatermarkData.LICENSE_ID_SIZE
    license_bytes = data[offset:license_end].rstrip(b'\x00')
    license_id = license_bytes.decode('utf-8')
    offset = license_end
    
    # Extract user info
    user_end = offset + WatermarkData.USER_INFO_SIZE
    user_bytes = data[offset:user_end].rstrip(b'\x00')
    user_info = user_bytes.decode('utf-8')
    offset = user_end
    
    # Extract timestamp
    timestamp_end = offset + WatermarkData.TIMESTAMP_SIZE
    timestamp = struct.unpack('>d', data[offset:timestamp_end])[0]
    offset = timestamp_end
    
    # Extract signature
    signature_end = offset + WatermarkData.SIGNATURE_SIZE
    stored_signature = data[offset:signature_end]
    
    # Verify signature
    payload = data[:offset]
    expected_signature = _calculate_signature(payload, secret)
    
    if not hmac.compare_digest(stored_signature, expected_signature):
        raise WatermarkError("Signature verification failed")
    
    # Create watermark object
    watermark = WatermarkData(license_id, user_info, timestamp)
    watermark.signature = stored_signature
    
    return watermark


def embed_watermark_in_binary(binary_data: bytes, watermark: WatermarkData, 
                               secret: str) -> bytes:
    """
    Embed a watermark into binary data without affecting deterministic properties.
    
    The watermark is appended to the end of the binary data, preserving the
    original data integrity while adding traceable licensing information.
    
    Args:
        binary_data: Original binary data
        watermark: Watermark data to embed
        secret: Secret key for signature
        
    Returns:
        Binary data with embedded watermark
        
    Raises:
        WatermarkError: If embedding fails
    """
    try:
        encoded_watermark = encode_watermark(watermark, secret)
        return binary_data + encoded_watermark
    except Exception as e:
        raise WatermarkError(f"Failed to embed watermark: {e}")


def extract_watermark_from_binary(binary_data: bytes, 
                                   secret: str) -> Tuple[bytes, WatermarkData]:
    """
    Extract and verify watermark from binary data.
    
    Args:
        binary_data: Binary data with embedded watermark
        secret: Secret key for verification
        
    Returns:
        Tuple of (original_data, watermark_data)
        
    Raises:
        WatermarkError: If extraction or verification fails
    """
    if len(binary_data) < WatermarkData.WATERMARK_SIZE:
        raise WatermarkError("Binary data too small to contain watermark")
    
    # Extract watermark from end of data
    watermark_offset = len(binary_data) - WatermarkData.WATERMARK_SIZE
    original_data = binary_data[:watermark_offset]
    watermark_bytes = binary_data[watermark_offset:]
    
    # Decode and verify watermark
    watermark = decode_watermark(watermark_bytes, secret)
    
    return original_data, watermark


def check_watermark_present(binary_data: bytes) -> bool:
    """
    Check if binary data contains a watermark without verifying it.
    
    Args:
        binary_data: Binary data to check
        
    Returns:
        True if watermark magic bytes are present
    """
    if len(binary_data) < WatermarkData.WATERMARK_SIZE:
        return False
    
    watermark_offset = len(binary_data) - WatermarkData.WATERMARK_SIZE
    magic = binary_data[watermark_offset:watermark_offset + 4]
    
    return magic == WatermarkData.MAGIC
