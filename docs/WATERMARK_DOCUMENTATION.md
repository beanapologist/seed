# Watermark Integration Documentation

## Overview

The watermarking system provides secure licensing and traceability for binary outputs generated by this repository. It embeds unique, cryptographically-signed licensing data into binary files without affecting their deterministic properties.

## Features

- **Secure Embedding**: Watermarks are cryptographically signed using HMAC-SHA256
- **Traceable Licensing**: Each watermark contains License ID, User Information, and Timestamp
- **Non-Invasive**: Original binary data is preserved exactly; watermark is appended
- **Verifiable**: Built-in verification tools validate authenticity and licensing
- **Compliant**: Adheres strictly to COMMERCIAL_LICENSE.md requirements

## Watermark Structure

Each watermark consists of 237 bytes:

```
+----------------+----------+--------------------------------------+
| Field          | Size     | Description                          |
+----------------+----------+--------------------------------------+
| Magic Bytes    | 4 bytes  | 'SEED' identifier                    |
| Version        | 1 byte   | Format version (currently 1)         |
| License ID     | 64 bytes | Unique license identifier (padded)   |
| User Info      | 128 bytes| User/organization info (padded)      |
| Timestamp      | 8 bytes  | Unix timestamp (double, big-endian)  |
| Signature      | 32 bytes | HMAC-SHA256 signature                |
+----------------+----------+--------------------------------------+
```

## Installation

The watermark module is included in the `gq` package:

```bash
pip install -e .
```

## Usage

### Creating Watermarked Binaries

Use the `create_watermarked_binary.py` script to embed watermarks:

```bash
python scripts/create_watermarked_binary.py \
    --input formats/golden_seed_256.bin \
    --output output/watermarked_seed.bin \
    --license-id "LICENSE-2026-001" \
    --user-info "Acme Corporation" \
    --secret "your-secret-key"
```

Using environment variable for secret (recommended):

```bash
export WATERMARK_SECRET="your-secret-key"
python scripts/create_watermarked_binary.py \
    --input formats/golden_seed_256.bin \
    --output output/watermarked_seed.bin \
    --license-id "LICENSE-2026-001" \
    --user-info "Acme Corporation"
```

### Verifying Watermarked Binaries

Use the `verify_watermark.py` script to verify and extract watermark information:

```bash
python scripts/verify_watermark.py \
    --input output/watermarked_seed.bin \
    --secret "your-secret-key"
```

For JSON output (useful for automation):

```bash
python scripts/verify_watermark.py \
    --input output/watermarked_seed.bin \
    --secret "your-secret-key" \
    --json
```

### Programmatic Usage

You can also use the watermark API directly in Python:

```python
from gq.watermark import (
    WatermarkData,
    embed_watermark_in_binary,
    extract_watermark_from_binary,
    check_watermark_present
)

# Create watermark
watermark = WatermarkData(
    license_id="LICENSE-2026-001",
    user_info="Acme Corporation"
)

# Read original binary
with open('input.bin', 'rb') as f:
    binary_data = f.read()

# Embed watermark
secret = "your-secret-key"
watermarked = embed_watermark_in_binary(binary_data, watermark, secret)

# Write watermarked binary
with open('output.bin', 'wb') as f:
    f.write(watermarked)

# Later: verify and extract
with open('output.bin', 'rb') as f:
    watermarked_data = f.read()

if check_watermark_present(watermarked_data):
    original, extracted_watermark = extract_watermark_from_binary(
        watermarked_data, secret
    )
    print(f"License ID: {extracted_watermark.license_id}")
    print(f"User: {extracted_watermark.user_info}")
```

## Security Considerations

### Secret Key Management

- **Keep secrets secure**: The secret key is used for HMAC signature generation and verification
- **Use strong secrets**: Choose a long, random secret key (at least 32 characters)
- **Environment variables**: Use `WATERMARK_SECRET` environment variable instead of command-line arguments
- **Key rotation**: If a secret is compromised, generate new watermarks with a new secret

### Signature Verification

The watermark uses HMAC-SHA256 to ensure:
- **Authenticity**: Only parties with the secret can create valid watermarks
- **Integrity**: Any tampering with the watermark will be detected
- **Non-repudiation**: Watermark cannot be forged without the secret

### Limitations

⚠️ **Important**: This watermarking system is designed for licensing and traceability, NOT for cryptographic security:

- Watermarks are appended, not encrypted or obfuscated
- Anyone can see the watermark structure (license ID, user info, timestamp)
- The secret key only protects against forgery, not disclosure
- Original binary data remains readable

## Deterministic Properties

The watermark system is designed to **preserve deterministic properties** of the binary data:

- **Original data unchanged**: The watermark is appended, not embedded within the data
- **Extraction restores original**: Extracting the watermark returns the exact original binary
- **Reproducible**: The same inputs produce the same outputs (except for timestamp)

### Testing Determinism

```python
# Original binary
original = b'\x00\x01\x02\x03'

# Embed watermark
watermarked = embed_watermark_in_binary(original, watermark, secret)

# Extract
extracted_original, _ = extract_watermark_from_binary(watermarked, secret)

# Verify determinism
assert original == extracted_original  # Byte-for-byte identical
```

## Compliance with COMMERCIAL_LICENSE.md

This watermarking system ensures compliance with the commercial license requirements:

1. **Traceability**: Each watermarked binary contains traceable licensing information
2. **Authorization**: Only authorized parties with the secret can create valid watermarks
3. **Verification**: Built-in tools allow easy verification of licensing status
4. **Non-repudiation**: Cryptographic signatures prevent forgery

### Compliance Workflow

1. **License Grant**: When granting a commercial license, provide the licensee with:
   - Unique License ID
   - Secret key for watermarking
   - Access to watermarking tools

2. **Binary Creation**: Licensee creates watermarked binaries using provided credentials

3. **Distribution**: Watermarked binaries can be distributed as per license terms

4. **Verification**: Anyone with the secret can verify licensing information

## API Reference

### WatermarkData

Container for watermark licensing data.

**Constructor:**
```python
WatermarkData(license_id: str, user_info: str, timestamp: Optional[float] = None)
```

- `license_id`: Unique license identifier (max 64 characters)
- `user_info`: User or organization information (max 128 characters)
- `timestamp`: Unix timestamp (defaults to current time)

**Methods:**
- `to_dict()`: Convert watermark data to dictionary

### Functions

#### encode_watermark

```python
encode_watermark(watermark: WatermarkData, secret: str) -> bytes
```

Encode watermark data into binary format with cryptographic signature.

#### decode_watermark

```python
decode_watermark(data: bytes, secret: str) -> WatermarkData
```

Decode and verify watermark data from binary format.

#### embed_watermark_in_binary

```python
embed_watermark_in_binary(binary_data: bytes, watermark: WatermarkData, secret: str) -> bytes
```

Embed a watermark into binary data without affecting deterministic properties.

#### extract_watermark_from_binary

```python
extract_watermark_from_binary(binary_data: bytes, secret: str) -> Tuple[bytes, WatermarkData]
```

Extract and verify watermark from binary data. Returns tuple of (original_data, watermark_data).

#### check_watermark_present

```python
check_watermark_present(binary_data: bytes) -> bool
```

Check if binary data contains a watermark without verifying it.

### Exceptions

#### WatermarkError

Base exception for all watermark operations. Raised when:
- Field size limits are exceeded
- Encoding/decoding fails
- Signature verification fails
- Invalid watermark format detected

## Examples

### Example 1: Batch Processing

```python
import os
from pathlib import Path
from gq.watermark import WatermarkData, embed_watermark_in_binary

secret = os.environ['WATERMARK_SECRET']

# Process multiple files
for input_file in Path('input').glob('*.bin'):
    with open(input_file, 'rb') as f:
        data = f.read()
    
    watermark = WatermarkData(
        license_id=f"LICENSE-2026-{input_file.stem}",
        user_info="Batch Processing User"
    )
    
    watermarked = embed_watermark_in_binary(data, watermark, secret)
    
    output_file = Path('output') / f"watermarked_{input_file.name}"
    with open(output_file, 'wb') as f:
        f.write(watermarked)
    
    print(f"Processed: {input_file} -> {output_file}")
```

### Example 2: Verification Pipeline

```python
from gq.watermark import extract_watermark_from_binary, check_watermark_present

def verify_license(binary_file: Path, secret: str) -> dict:
    """Verify licensing information from binary file."""
    with open(binary_file, 'rb') as f:
        data = f.read()
    
    if not check_watermark_present(data):
        return {'valid': False, 'reason': 'No watermark present'}
    
    try:
        original, watermark = extract_watermark_from_binary(data, secret)
        return {
            'valid': True,
            'license_id': watermark.license_id,
            'user_info': watermark.user_info,
            'timestamp': watermark.timestamp
        }
    except Exception as e:
        return {'valid': False, 'reason': str(e)}
```

## Testing

Run the comprehensive test suite:

```bash
python -m unittest test_watermark -v
```

The test suite includes:
- Watermark data structure tests
- Encoding/decoding tests
- Binary embedding/extraction tests
- Signature verification tests
- Deterministic property validation
- Edge case handling

## Troubleshooting

### "Signature verification failed"

This error occurs when:
- Wrong secret key is used for verification
- Watermark data has been tampered with
- Watermark format is corrupted

**Solution**: Ensure you're using the correct secret key.

### "Invalid watermark size"

This error occurs when:
- Binary data is too small to contain a watermark
- File has been truncated

**Solution**: Verify the file integrity and size.

### "License ID exceeds 64 bytes"

This error occurs when:
- License ID string is too long

**Solution**: Use a shorter license ID (max 64 characters).

## License and Compliance

All watermarked binaries created with this system are subject to the terms specified in `COMMERCIAL_LICENSE.md`. 

**Key Requirements:**
- Redistribution in source or binary forms requires specific prior written permission
- Governed by the laws of the State of California
- Unauthorized commercial data teleportation or redistribution is prohibited

For commercial licensing inquiries, refer to `COMMERCIAL_LICENSE.md`.
